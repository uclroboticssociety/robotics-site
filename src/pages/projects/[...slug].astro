---
import Base from "../../layouts/Base.astro";
import { getCollection } from "astro:content";
import type { ImageMetadata } from "astro";
import EventsLayout from "../../components/events/EventsLayout.astro";

export async function getStaticPaths() {
  const projects = await getCollection("projects");
  const shortSlug = (entry) =>
    entry.slug.includes("/") ? entry.slug.split("/")[0] : entry.slug;
  return projects.map((project) => ({
    params: { slug: shortSlug(project) },
  }));
}

const slugParam = Astro.params.slug;
const slug = Array.isArray(slugParam) ? slugParam.join("/") : slugParam;

const projects = await getCollection("projects");
const shortSlug = (entry) =>
  entry.slug.includes("/") ? entry.slug.split("/")[0] : entry.slug;
const project = projects.find(
  (entry) => entry.slug === slug || shortSlug(entry) === slug
);

if (!project) {
  throw new Error(`Project not found: ${slug ?? "unknown"}`);
}

const sortByStatus: Record<string, number> = {
  active: 0,
  paused: 1,
  completed: 2,
};
const sorted = projects
  .slice()
  .sort((a, b) => sortByStatus[a.data.status] - sortByStatus[b.data.status]);

const projectSidebar = [
  {
    id: "vla",
    emoji: "ðŸ¤–",
    title: "VLA",
    href: "/projects",
    description: "Vision-Language-Action research and build track.",
    tag: "vla",
  },
];

const recentByInitiative = {
  vla: sorted.map((entry) => ({
    title: entry.data.title,
    href: `/projects/${shortSlug(entry)}`,
  })),
};

const body = project.body ?? "";
const pictureRegex = /\[picture\]\s*"([^"]+)"(?:\((\d+)%\))?/g;
const spaceRegex = /\[space\]\s*"([^"]+)"/g;
const scrollRegex = /\[scroll\]\(([\s\S]*?)\)/g;
type Block =
  | { type: "text"; value: string }
  | { type: "image"; value: string; width?: number }
  | { type: "scroll"; value: string[] }
  | { type: "space"; value: string }
  | { type: "split"; media: { type: "image" | "scroll"; value: string | string[] }; text: string; mediaSide: "left" | "right" };

const parseScrollImages = (text: string) => {
  const images: string[] = [];
  for (const match of text.matchAll(pictureRegex)) {
    images.push(match[1]);
  }
  return images;
};

const splitSegments = (input: string) =>
  input
    .split("/!!!")
    .map((segment) => segment.replace("!!!/", "").trim())
    .filter(Boolean);

const parseSegment = (segment: string): Block[] => {
  const blocks: Block[] = [];
  let lastIndex = 0;
  for (const match of segment.matchAll(scrollRegex)) {
    const textChunk = segment.slice(lastIndex, match.index).trim();
    if (textChunk) blocks.push({ type: "text", value: textChunk });
    const images = parseScrollImages(match[1]);
    if (images.length) {
      blocks.push({ type: "scroll", value: images });
    }
    lastIndex = (match.index ?? 0) + match[0].length;
  }
  const tail = segment.slice(lastIndex).trim();
  if (tail) blocks.push({ type: "text", value: tail });
  return blocks;
};

const segments = splitSegments(body).map(parseSegment);

const expandPictures = (input: Block[]) => {
  const out: Block[] = [];
  input.forEach((block) => {
    if (block.type !== "text") {
      out.push(block);
      return;
    }
    const text = block.value;
    const markers = [...text.matchAll(pictureRegex), ...text.matchAll(spaceRegex)]
      .sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
    let last = 0;
    for (const match of markers) {
      const chunk = text.slice(last, match.index).trim();
      if (chunk) out.push({ type: "text", value: chunk });
      if (match[0].startsWith("[picture]")) {
        const width = match[2] ? Number(match[2]) : undefined;
        out.push({ type: "image", value: match[1], width });
      } else {
        out.push({ type: "space", value: match[1] });
      }
      last = (match.index ?? 0) + match[0].length;
    }
    const tailText = text.slice(last).trim();
    if (tailText) out.push({ type: "text", value: tailText });
  });
  return out;
};

const normalizeSegment = (segmentBlocks: Block[]) => {
  const expanded = expandPictures(segmentBlocks);
  const out: Block[] = [];
  for (let i = 0; i < expanded.length; i += 1) {
    const current = expanded[i];
    const next = expanded[i + 1];
    if (current.type === "scroll" && next?.type === "text") {
      out.push({
        type: "split",
        media: { type: "scroll", value: current.value },
        text: next.value,
        mediaSide: "left",
      });
      i += 1;
      continue;
    }
    if (current.type === "text" && next?.type === "scroll") {
      out.push({
        type: "split",
        media: { type: "scroll", value: next.value },
        text: current.value,
        mediaSide: "right",
      });
      i += 1;
      continue;
    }
    out.push(current);
  }
  return out;
};

const imageMap = import.meta.glob<ImageMetadata>(
  "/src/content/projects/**/*.{png,jpg,jpeg,webp,gif,svg}",
  { eager: true, import: "default" }
);
const baseDir = project.id.split("/").slice(0, -1).join("/");
const resolveImage = (file: string) => {
  const directKey = `/src/content/projects/${baseDir}/${file}`;
  const fallbackKey = `/src/content/projects/${file}`;
  const image = imageMap[directKey] ?? imageMap[fallbackKey];
  return image?.src ?? "";
};
const imageAlt = (file: string) =>
  file
    .replace(/\.[^/.]+$/, "")
    .replace(/[-_]+/g, " ")
    .trim();

const renderInline = (text: string) =>
  text.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");

const renderInlineWithBreaks = (text: string) =>
  renderInline(text.trim()).replace(/\\n|\n/g, "<br />");

const renderMarkdown = (text: string) => {
  const normalized = text.replace(/\\n/g, "\n");
  const lines = normalized.split("\n");
  const html: string[] = [];
  const listStack: number[] = [];
  let paragraph: string[] = [];

  const closeParagraph = () => {
    if (!paragraph.length) return;
    html.push(
      `<p class="text-base md:text-lg leading-relaxed text-slate-700">${renderInline(
        paragraph.join(" ")
      )}</p>`
    );
    paragraph = [];
  };

  const closeLists = (targetLevel = 0) => {
    while (listStack.length > targetLevel) {
      html.push("</ul>");
      listStack.pop();
    }
  };

  const openList = () => {
    html.push('<ul class="list-disc pl-6 space-y-1 text-slate-700">');
    listStack.push(1);
  };

  lines.forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed) {
      closeParagraph();
      return;
    }

    if (trimmed === "---") {
      closeParagraph();
      closeLists(0);
      html.push('<hr class="my-6 border-slate-200" />');
      return;
    }

    if (trimmed.startsWith("## ")) {
      closeParagraph();
      closeLists(0);
      html.push(
        `<h2 class="mt-6 mb-2 text-xl md:text-2xl font-semibold text-slate-900">${renderInline(
          trimmed.slice(3)
        )}</h2>`
      );
      return;
    }

    if (trimmed.startsWith("### ")) {
      closeParagraph();
      closeLists(0);
      html.push(
        `<h3 class="mt-4 text-lg md:text-xl font-semibold text-slate-900">${renderInline(
          trimmed.slice(4)
        )}</h3>`
      );
      return;
    }

    const listMatch = line.match(/^(\s*)-\s+(.*)$/);
    if (listMatch) {
      const indent = listMatch[1].length;
      const level = Math.floor(indent / 2);
      closeParagraph();

      if (listStack.length < level + 1) {
        openList();
      } else if (listStack.length > level + 1) {
        closeLists(level + 1);
      }

      html.push(`<li>${renderInline(listMatch[2])}</li>`);
      return;
    }

    paragraph.push(trimmed);
  });

  closeParagraph();
  closeLists(0);
  return html.join("");
};
---

<Base title={`${project.data.title} â€” Robotics Society`}>
  <style>
    .fade-once {
      opacity: 0;
      transform: translateY(24px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }
    .fade-once.is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    .scroll-frame {
      width: 100%;
      border-radius: 16px;
      overflow-x: auto;
      border: 1px solid rgb(226 232 240);
      background: #f8fafc;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .scroll-track {
      display: flex;
      gap: 12px;
      padding: 10px;
      min-width: 100%;
    }
    .scroll-track img {
      flex: 0 0 100%;
      aspect-ratio: 16 / 9;
      width: 100%;
      height: auto;
      object-fit: cover;
      border-radius: 12px;
      scroll-snap-align: start;
    }
    .space-block {
      height: var(--space-height);
    }
  </style>
  <EventsLayout
    title={project.data.title}
    initiatives={projectSidebar}
    currentId="vla"
    recentByInitiative={recentByInitiative}
    currentEventHref={`/projects/${shortSlug(project)}`}
    showHeader={false}
  >
    <section>
      <article class="mx-auto max-w-3xl fade-once">
        <header class="border-b border-slate-200 pb-6">
          <h1 class="text-3xl md:text-4xl font-semibold tracking-tight text-slate-900">
            {project.data.title}
          </h1>
          <div class="mt-4 flex flex-wrap items-center gap-3 text-sm text-slate-500">
            <span class="capitalize">{project.data.status}</span>
            {project.data.lead && <span>Lead: {project.data.lead}</span>}
          </div>
          {project.data.summary && (
            <p class="mt-3 text-slate-600">{project.data.summary}</p>
          )}
        </header>
        <div class="mt-8 space-y-6">
          {segments.map((segment, segmentIndex) => {
            const normalized = normalizeSegment(segment);
            return (
              <div class="space-y-6" data-segment={segmentIndex}>
                {(() => {
                  const rendered: any[] = [];
                  for (let i = 0; i < normalized.length; i += 1) {
                    const block = normalized[i];
                    const next = normalized[i + 1];
                    if (block.type === "image" && next?.type === "image") {
                      const srcA = resolveImage(block.value);
                      const srcB = resolveImage(next.value);
                      const widthA = block.width;
                      const widthB = next.width;
                      const useFlex = widthA || widthB;
                      const rowClass = useFlex ? "flex flex-wrap gap-4 items-start justify-center" : "grid gap-4 md:grid-cols-2";
                      rendered.push(
                        <div class={rowClass}>
                          {srcA ? (
                            <img
                              src={srcA}
                              alt={imageAlt(block.value)}
                              class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                              style={widthA ? `width:${widthA}%; margin-left:auto; margin-right:auto;` : undefined}
                              loading="lazy"
                            />
                          ) : (
                            <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                              Image not found: {block.value}
                            </div>
                          )}
                          {srcB ? (
                            <img
                              src={srcB}
                              alt={imageAlt(next.value)}
                              class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                              style={widthB ? `width:${widthB}%; margin-left:auto; margin-right:auto;` : undefined}
                              loading="lazy"
                            />
                          ) : (
                            <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                              Image not found: {next.value}
                            </div>
                          )}
                        </div>
                      );
                      i += 1;
                      continue;
                    }

                    if (block.type === "scroll") {
                      const images = block.value.map((img) => resolveImage(img)).filter(Boolean);
                      rendered.push(
                        <div class="scroll-frame">
                          <div class="scroll-track">
                            {images.map((src, index) => (
                              <img src={src} alt={imageAlt(block.value[index])} loading="lazy" />
                            ))}
                          </div>
                        </div>
                      );
                      continue;
                    }

                    if (block.type === "split") {
                      const mediaLeft = block.mediaSide === "left";
                      const mediaImages =
                        block.media.type === "scroll"
                          ? block.media.value.map((img) => resolveImage(img)).filter(Boolean)
                          : [resolveImage(block.media.value as string)].filter(Boolean);
                      const mediaNode =
                        block.media.type === "scroll" ? (
                          <div class="scroll-frame">
                            <div class="scroll-track">
                              {mediaImages.map((src, index) => (
                                <img src={src} alt={imageAlt((block.media.value as string[])[index])} loading="lazy" />
                              ))}
                            </div>
                          </div>
                        ) : mediaImages[0] ? (
                          <img
                            src={mediaImages[0]}
                            alt={imageAlt(block.media.value as string)}
                            class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                            loading="lazy"
                          />
                        ) : (
                          <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                            Image not found: {block.media.value as string}
                          </div>
                        );
                      rendered.push(
                        <div class="grid gap-6 md:grid-cols-2 items-start">
                          {mediaLeft && mediaNode}
                          <div set:html={renderMarkdown(block.text)} />
                          {!mediaLeft && mediaNode}
                        </div>
                      );
                      continue;
                    }

                    if (block.type === "image") {
                      const src = resolveImage(block.value);
                      rendered.push(
                        src ? (
                          <img
                            src={src}
                            alt={imageAlt(block.value)}
                            class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                            style={block.width ? `width:${block.width}%; margin-left:auto; margin-right:auto;` : undefined}
                            loading="lazy"
                          />
                        ) : (
                          <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                            Image not found: {block.value}
                          </div>
                        )
                      );
                      continue;
                    }

                    if (block.type === "space") {
                      rendered.push(<div class="space-block" style={`--space-height:${block.value};`} />);
                      continue;
                    }

                    rendered.push(<div set:html={renderMarkdown(block.value)} />);
                  }
                  return rendered;
                })()}
              </div>
            );
          })}
        </div>
      </article>
    </section>
  </EventsLayout>
</Base>

<script>
  const content = document.querySelector('.fade-once');
  if (content) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;
        entry.target.classList.add('is-visible');
        observer.unobserve(entry.target);
      });
    }, { threshold: 0.2 });

    observer.observe(content);
  }
</script>
