---
import Base from "../../layouts/Base.astro";
import { getCollection } from "astro:content";
import type { ImageMetadata } from "astro";
import EventsLayout from "../../components/events/EventsLayout.astro";
import { initiatives } from "../../data/events";

export async function getStaticPaths() {
  const allEvents = await getCollection("events");
  const shortSlugFromEntry = (entry) =>
    entry.slug.includes("/") ? entry.slug.split("/")[0] : entry.slug;
  return allEvents.map((event) => ({
    params: { slug: shortSlugFromEntry(event) },
  }));
}

const slugParam = Astro.params.slug;
const slug = Array.isArray(slugParam) ? slugParam.join("/") : slugParam;

const allEvents = await getCollection("events");
const shortSlugFromEntry = (entry) =>
  entry.slug.includes("/") ? entry.slug.split("/")[0] : entry.slug;
const event = allEvents.find(
  (entry) => entry.slug === slug || shortSlugFromEntry(entry) === slug
);

if (!event) {
  throw new Error(`Event not found: ${slug ?? "unknown"}`);
}

const sortByDate = (a, b) => new Date(b.data.date).getTime() - new Date(a.data.date).getTime();
const workshops = allEvents.filter((e) => e.data.tags?.includes("workshop")).sort(sortByDate);
const hackathons = allEvents.filter((e) => e.data.tags?.includes("hackathon")).sort(sortByDate);
const challenges = allEvents.filter((e) => e.data.tags?.includes("challenge")).sort(sortByDate);
const socials = allEvents.filter((e) => e.data.tags?.includes("social")).sort(sortByDate);

const folderLabel = (item) => item.id.split("/").slice(-2, -1)[0] ?? item.data.title;
const recentByInitiative = {
  workshops: workshops.map((item) => ({
    title: folderLabel(item),
    href: `/events/${shortSlugFromEntry(item)}`,
  })),
  hackathons: hackathons.map((item) => ({
    title: folderLabel(item),
    href: `/events/${shortSlugFromEntry(item)}`,
  })),
  challenges: challenges.map((item) => ({
    title: folderLabel(item),
    href: `/events/${shortSlugFromEntry(item)}`,
  })),
  socials: socials.map((item) => ({
    title: folderLabel(item),
    href: `/events/${shortSlugFromEntry(item)}`,
  })),
};

const tagLabels: Record<string, string> = {
  workshop: "Workshop",
  hackathon: "Hackathon",
  challenge: "Challenge",
  social: "Social",
};

const currentInitiative = initiatives.find((item) => event.data.tags?.includes(item.tag));
const currentId = currentInitiative?.id;
const currentEventHref = `/events/${shortSlugFromEntry(event)}`;

const body = event.body ?? "";
const pictureRegex = /\[picture\]\s*"([^"]+)"(?:\((\d+)%\))?/g;
const pdfRegex = /\[pdf\]\s*"([^"]+)"(?:\((\d+)%\))?/g;
const spaceRegex = /\[space\]\s*"([^"]+)"/g;
const scrollRegex = /\[scroll\]\(([\s\S]*?)\)/g;
const scrollFolderRegex = /\[scroll_folder\]\s*"([^"]+)"(?:\((\d+)%\))?/g;
type Block =
  | { type: "text"; value: string }
  | { type: "image"; value: string; width?: number }
  | { type: "pdf"; value: string; width?: number }
  | { type: "scroll_folder"; value: string; width?: number }
  | { type: "scroll"; value: string[] }
  | { type: "space"; value: string }
  | { type: "split"; media: { type: "image" | "scroll"; value: string | string[]; folder?: string; width?: number }; text: string; mediaSide: "left" | "right" };

const parseScrollImages = (text: string) => {
  const images: string[] = [];
  for (const match of text.matchAll(pictureRegex)) {
    images.push(match[1]);
  }
  return images;
};

const splitSegments = (input: string) =>
  input
    .split("/!!!")
    .map((segment) => segment.replace("!!!/", "").trim())
    .filter(Boolean);

const parseSegment = (segment: string): Block[] => {
  const blocks: Block[] = [];
  const matches = [
    ...segment.matchAll(scrollRegex),
    ...segment.matchAll(scrollFolderRegex),
  ].sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
  let lastIndex = 0;
  for (const match of matches) {
    const textChunk = segment.slice(lastIndex, match.index).trim();
    if (textChunk) blocks.push({ type: "text", value: textChunk });
    if (match[0].startsWith("[scroll_folder]")) {
      const width = match[2] ? Number(match[2]) : undefined;
      blocks.push({ type: "scroll_folder", value: match[1], width });
    } else {
      const images = parseScrollImages(match[1]);
      if (images.length) {
        blocks.push({ type: "scroll", value: images });
      }
    }
    lastIndex = (match.index ?? 0) + match[0].length;
  }
  const tail = segment.slice(lastIndex).trim();
  if (tail) blocks.push({ type: "text", value: tail });
  return blocks;
};

const segments = splitSegments(body).map(parseSegment);

const expandPictures = (input: Block[]) => {
  const out: Block[] = [];
  input.forEach((block) => {
    if (block.type !== "text") {
      out.push(block);
      return;
    }
    const text = block.value;
    const markers = [...text.matchAll(pictureRegex), ...text.matchAll(pdfRegex), ...text.matchAll(spaceRegex)]
      .sort((a, b) => (a.index ?? 0) - (b.index ?? 0));
    let last = 0;
    for (const match of markers) {
      const chunk = text.slice(last, match.index).trim();
      if (chunk) out.push({ type: "text", value: chunk });
      if (match[0].startsWith("[picture]")) {
        const width = match[2] ? Number(match[2]) : undefined;
        out.push({ type: "image", value: match[1], width });
      } else if (match[0].startsWith("[pdf]")) {
        const width = match[2] ? Number(match[2]) : undefined;
        out.push({ type: "pdf", value: match[1], width });
      } else {
        out.push({ type: "space", value: match[1] });
      }
      last = (match.index ?? 0) + match[0].length;
    }
    const tailText = text.slice(last).trim();
    if (tailText) out.push({ type: "text", value: tailText });
  });
  return out;
};

const normalizeSegment = (segmentBlocks: Block[]) => {
  const expanded = expandPictures(segmentBlocks);
  const out: Block[] = [];
  for (let i = 0; i < expanded.length; i += 1) {
    const current = expanded[i];
    const next = expanded[i + 1];
    if ((current.type === "scroll" || current.type === "scroll_folder") && next?.type === "text") {
      out.push({
        type: "split",
        media: { type: "scroll", value: current.type === "scroll" ? current.value : [], folder: current.type === "scroll_folder" ? current.value : undefined, width: current.type === "scroll_folder" ? current.width : undefined },
        text: next.value,
        mediaSide: "left",
      });
      i += 1;
      continue;
    }
    if (current.type === "text" && (next?.type === "scroll" || next?.type === "scroll_folder")) {
      out.push({
        type: "split",
        media: { type: "scroll", value: next.type === "scroll" ? next.value : [], folder: next.type === "scroll_folder" ? next.value : undefined, width: next.type === "scroll_folder" ? next.width : undefined },
        text: current.value,
        mediaSide: "right",
      });
      i += 1;
      continue;
    }
    out.push(current);
  }
  return out;
};

const imageMap = import.meta.glob<ImageMetadata>(
  "/src/content/events/**/*.{png,jpg,jpeg,webp,gif,svg}",
  { eager: true, import: "default" }
);
const pdfMap = import.meta.glob<{ default: string }>(
  "/src/content/events/**/*.pdf",
  { eager: true }
);
const baseDir = event.id.split("/").slice(0, -1).join("/");
const resolveImage = (file: string) => {
  const directKey = `/src/content/events/${baseDir}/${file}`;
  const fallbackKey = `/src/content/events/${file}`;
  const image = imageMap[directKey] ?? imageMap[fallbackKey];
  return image?.src ?? "";
};
const resolveFolderImages = (folder: string) => {
  const folderPrefix = `/src/content/events/${baseDir}/${folder}/`;
  return Object.entries(imageMap)
    .filter(([key]) => key.startsWith(folderPrefix))
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([, value]) => value.src);
};
const resolvePdf = (file: string) => {
  const directKey = `/src/content/events/${baseDir}/${file}`;
  const fallbackKey = `/src/content/events/${file}`;
  const pdf = pdfMap[directKey] ?? pdfMap[fallbackKey];
  return (pdf as any)?.default ?? "";
};
const imageAlt = (file: string) =>
  file
    .replace(/\.[^/.]+$/, "")
    .replace(/[-_]+/g, " ")
    .trim();

const renderInline = (text: string) =>
  text.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");

const renderInlineWithBreaks = (text: string) =>
  renderInline(text.trim()).replace(/\\n|\n/g, "<br />");

const renderMarkdown = (text: string) => {
  const normalized = text.replace(/\\n/g, "\n");
  const lines = normalized.split("\n");
  const html: string[] = [];
  const listStack: number[] = [];
  let paragraph: string[] = [];

  const closeParagraph = () => {
    if (!paragraph.length) return;
    html.push(
      `<p class="text-base md:text-lg leading-relaxed text-slate-700">${renderInline(
        paragraph.join(" ")
      )}</p>`
    );
    paragraph = [];
  };

  const closeLists = (targetLevel = 0) => {
    while (listStack.length > targetLevel) {
      html.push("</ul>");
      listStack.pop();
    }
  };

  const openList = () => {
    html.push('<ul class="list-disc pl-6 space-y-1 text-slate-700">');
    listStack.push(1);
  };

  lines.forEach((line) => {
    const trimmed = line.trim();
    if (!trimmed) {
      closeParagraph();
      return;
    }

    if (trimmed === "---") {
      closeParagraph();
      closeLists(0);
      html.push('<hr class="my-6 border-slate-200" />');
      return;
    }

    if (trimmed.startsWith("## ")) {
      closeParagraph();
      closeLists(0);
      html.push(
        `<h2 class="mt-1 mb-2 text-xl md:text-2xl font-semibold text-slate-900">${renderInline(
          trimmed.slice(3)
        )}</h2>`
      );
      return;
    }

    if (trimmed.startsWith("### ")) {
      closeParagraph();
      closeLists(0);
      html.push(
        `<h3 class="mt-4 text-lg md:text-xl font-semibold text-slate-900">${renderInline(
          trimmed.slice(4)
        )}</h3>`
      );
      return;
    }

    const listMatch = line.match(/^(\s*)-\s+(.*)$/);
    if (listMatch) {
      const indent = listMatch[1].length;
      const level = Math.floor(indent / 2);
      closeParagraph();

      if (listStack.length < level + 1) {
        openList();
      } else if (listStack.length > level + 1) {
        closeLists(level + 1);
      }

      html.push(`<li>${renderInline(listMatch[2])}</li>`);
      return;
    }

    paragraph.push(trimmed);
  });

  closeParagraph();
  closeLists(0);
  return html.join("");
};

const primaryTag = event.data.tags?.map((tag) => tagLabels[tag]).find(Boolean);

const formatDate = (iso: string) => {
  const date = new Date(iso);
  return date.toLocaleDateString("en-US", {
    weekday: "short",
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
};
---

<Base title={`${event.data.title} â€” Robotics Society`}>
  <style>
    .fade-once {
      opacity: 0;
      transform: translateY(24px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }
    .fade-once.is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    .scroll-frame {
      width: 100%;
      border-radius: 16px;
      overflow-x: auto;
      border: 1px solid rgb(226 232 240);
      background: #f8fafc;
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.08);
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .scroll-track {
      display: flex;
      gap: 12px;
      padding: 10px;
      min-width: 100%;
    }
    .scroll-track img {
      flex: 0 0 100%;
      aspect-ratio: 16 / 9;
      width: 100%;
      height: auto;
      object-fit: cover;
      border-radius: 12px;
      scroll-snap-align: start;
    }
    .space-block {
      height: var(--space-height);
    }
  </style>
  <EventsLayout
    title={event.data.title}
    initiatives={initiatives}
    currentId={currentId}
    recentByInitiative={recentByInitiative}
    currentEventHref={currentEventHref}
    showHeader={false}
  >
    <section>
      <article class="mx-auto max-w-3xl fade-once">
        <header class="border-b border-slate-200 pb-6">
          <h1 class="text-3xl md:text-4xl font-semibold tracking-tight text-slate-900">
            {event.data.title}
          </h1>
          <div class="mt-4 flex flex-wrap items-center gap-3 text-sm text-slate-500">
            <span>{formatDate(event.data.date)}</span>
            {primaryTag && (
              <span class="rounded-full border border-slate-200 bg-white px-3 py-1 text-xs uppercase tracking-wide text-slate-600">
                {primaryTag}
              </span>
            )}
          </div>
          {event.data.location && (
            <p class="mt-3 flex items-center gap-1 text-slate-600">
              <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
              </svg>
              {event.data.location}
            </p>
          )}
        </header>
        <div class="mt-8 space-y-6">
          {segments.map((segment, segmentIndex) => {
            const normalized = normalizeSegment(segment);
            return (
              <div class="space-y-6" data-segment={segmentIndex}>
                {(() => {
                  const rendered: any[] = [];
                  for (let i = 0; i < normalized.length; i += 1) {
                    const block = normalized[i];
                    const next = normalized[i + 1];
                    if (block.type === "image" && next?.type === "image") {
                      const srcA = resolveImage(block.value);
                      const srcB = resolveImage(next.value);
                      const widthA = block.width;
                      const widthB = next.width;
                      const useFlex = widthA || widthB;
                      const rowClass = useFlex ? "flex flex-wrap gap-4 items-start justify-center" : "grid gap-4 md:grid-cols-2";
                      rendered.push(
                        <div class={rowClass}>
                          {srcA ? (
                            <img
                              src={srcA}
                              alt={imageAlt(block.value)}
                              class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                              style={widthA ? `width:${widthA}%; margin-left:auto; margin-right:auto;` : undefined}
                              loading="lazy"
                            />
                          ) : (
                            <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                              Image not found: {block.value}
                            </div>
                          )}
                          {srcB ? (
                            <img
                              src={srcB}
                              alt={imageAlt(next.value)}
                              class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                              style={widthB ? `width:${widthB}%; margin-left:auto; margin-right:auto;` : undefined}
                              loading="lazy"
                            />
                          ) : (
                            <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                              Image not found: {next.value}
                            </div>
                          )}
                        </div>
                      );
                      i += 1;
                      continue;
                    }

                    if (block.type === "scroll" || block.type === "scroll_folder") {
                      const images = block.type === "scroll"
                        ? block.value.map((img) => resolveImage(img)).filter(Boolean)
                        : resolveFolderImages(block.value);
                      rendered.push(
                        <div
                          class="scroll-frame"
                          style={block.type === "scroll_folder" && block.width ? `width:${block.width}%; margin-left:auto; margin-right:auto;` : undefined}
                        >
                          <div class="scroll-track">
                            {images.map((src, index) => (
                              <img src={src} alt={`scroll image ${index + 1}`} loading="lazy" />
                            ))}
                          </div>
                        </div>
                      );
                      continue;
                    }

                    if (block.type === "split") {
                      const mediaLeft = block.mediaSide === "left";
                      const mediaImages =
                        block.media.type === "scroll"
                          ? block.media.folder
                            ? resolveFolderImages(block.media.folder)
                            : block.media.value.map((img) => resolveImage(img)).filter(Boolean)
                          : [resolveImage(block.media.value as string)].filter(Boolean);
                      const mediaStyle =
                        block.media.type === "scroll" && block.media.width
                          ? `width:${block.media.width}%; margin-left:auto; margin-right:auto;`
                          : undefined;
                      const mediaNode =
                        block.media.type === "scroll" ? (
                          <div class="scroll-frame" style={mediaStyle}>
                            <div class="scroll-track">
                              {mediaImages.map((src, index) => (
                                <img src={src} alt={imageAlt((block.media.value as string[])[index])} loading="lazy" />
                              ))}
                            </div>
                          </div>
                        ) : mediaImages[0] ? (
                          <img
                            src={mediaImages[0]}
                            alt={imageAlt(block.media.value as string)}
                            class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                            loading="lazy"
                          />
                        ) : (
                          <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                            Image not found: {block.media.value as string}
                          </div>
                        );
                      rendered.push(
                        <div class="grid gap-6 md:grid-cols-2 items-start">
                          {mediaLeft && mediaNode}
                          <div set:html={renderMarkdown(block.text)} />
                          {!mediaLeft && mediaNode}
                        </div>
                      );
                      continue;
                    }

                    if (block.type === "image") {
                      const src = resolveImage(block.value);
                      rendered.push(
                        src ? (
                          <img
                            src={src}
                            alt={imageAlt(block.value)}
                            class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                            style={block.width ? `width:${block.width}%; margin-left:auto; margin-right:auto;` : undefined}
                            loading="lazy"
                          />
                        ) : (
                          <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                            Image not found: {block.value}
                          </div>
                        )
                      );
                      continue;
                    }

                    if (block.type === "pdf") {
                      const src = resolvePdf(block.value);
                      rendered.push(
                        src ? (
                          <iframe
                            src={src}
                            title={block.value}
                            class="w-full rounded-2xl border border-slate-200 bg-white/80 shadow-sm"
                            style={`${block.width ? `width:${block.width}%; margin-left:auto; margin-right:auto;` : ""} height: 70vh;`}
                          ></iframe>
                        ) : (
                          <div class="rounded-2xl border border-dashed border-slate-300 bg-white/60 px-4 py-6 text-sm text-slate-500">
                            PDF not found: {block.value}
                          </div>
                        )
                      );
                      continue;
                    }

                    if (block.type === "space") {
                      rendered.push(<div class="space-block" style={`--space-height:${block.value};`} />);
                      continue;
                    }

                    rendered.push(<div set:html={renderMarkdown(block.value)} />);
                  }
                  return rendered;
                })()}
              </div>
            );
          })}
        </div>
      </article>
    </section>
  </EventsLayout>
</Base>

<script>
  const content = document.querySelector('.fade-once');
  if (content) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (!entry.isIntersecting) return;
        entry.target.classList.add('is-visible');
        observer.unobserve(entry.target);
      });
    }, { threshold: 0.1, rootMargin: "0px 0px 20% 0px" });

    observer.observe(content);
  }
</script>
